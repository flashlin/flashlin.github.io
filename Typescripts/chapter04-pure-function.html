<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>純函數 | Flash&#39;s BLOG</title>
    <meta name="description" content="對於我這種只有一點點知識又沒錢的傢伙只好自行徒手建立這BLOG">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.8e755006.css" as="style"><link rel="preload" href="/blog/assets/js/app.9ca61cd2.js" as="script"><link rel="preload" href="/blog/assets/js/2.ed8abbfc.js" as="script"><link rel="preload" href="/blog/assets/js/28.dc3b4330.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e739b01c.js"><link rel="prefetch" href="/blog/assets/js/11.98e4feac.js"><link rel="prefetch" href="/blog/assets/js/12.675ace53.js"><link rel="prefetch" href="/blog/assets/js/13.b5737ebf.js"><link rel="prefetch" href="/blog/assets/js/14.4b6dbf6b.js"><link rel="prefetch" href="/blog/assets/js/15.d90406bf.js"><link rel="prefetch" href="/blog/assets/js/16.86e2395a.js"><link rel="prefetch" href="/blog/assets/js/17.635180c4.js"><link rel="prefetch" href="/blog/assets/js/18.281d9d19.js"><link rel="prefetch" href="/blog/assets/js/19.f0d2ed8f.js"><link rel="prefetch" href="/blog/assets/js/20.348ecd77.js"><link rel="prefetch" href="/blog/assets/js/21.f911f00a.js"><link rel="prefetch" href="/blog/assets/js/22.94c45d13.js"><link rel="prefetch" href="/blog/assets/js/23.b362a894.js"><link rel="prefetch" href="/blog/assets/js/24.1874b31c.js"><link rel="prefetch" href="/blog/assets/js/25.04bee451.js"><link rel="prefetch" href="/blog/assets/js/26.18bc6cc1.js"><link rel="prefetch" href="/blog/assets/js/27.9e4f28ae.js"><link rel="prefetch" href="/blog/assets/js/29.94f8c8c8.js"><link rel="prefetch" href="/blog/assets/js/3.abd2c393.js"><link rel="prefetch" href="/blog/assets/js/30.c1a0cc9e.js"><link rel="prefetch" href="/blog/assets/js/31.d9888b99.js"><link rel="prefetch" href="/blog/assets/js/32.d112d712.js"><link rel="prefetch" href="/blog/assets/js/33.4c57a876.js"><link rel="prefetch" href="/blog/assets/js/34.5c76547b.js"><link rel="prefetch" href="/blog/assets/js/35.b6373288.js"><link rel="prefetch" href="/blog/assets/js/36.58c85b15.js"><link rel="prefetch" href="/blog/assets/js/4.7f1bc4ba.js"><link rel="prefetch" href="/blog/assets/js/5.a0def24f.js"><link rel="prefetch" href="/blog/assets/js/6.b332c683.js"><link rel="prefetch" href="/blog/assets/js/7.362b20d2.js"><link rel="prefetch" href="/blog/assets/js/8.7cfcf1d3.js"><link rel="prefetch" href="/blog/assets/js/9.929138f1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8e755006.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Flash's BLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Home</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Typescripts</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/Typescripts/chapter00-readme.html" class="sidebar-link">Typescripts</a></li><li><a href="/blog/Typescripts/chapter01-curring.html" class="sidebar-link">Curring 柯里化</a></li><li><a href="/blog/Typescripts/chapter02-override-functions.html" class="sidebar-link">多載函數</a></li><li><a href="/blog/Typescripts/chapter03-generic-curring.html" class="sidebar-link">泛型柯里化</a></li><li><a href="/blog/Typescripts/chapter04-pure-function.html" class="active sidebar-link">純函數</a></li><li><a href="/blog/Typescripts/chapter05-cache-decorator.html" class="sidebar-link">快取裝飾器 Cache Decorator</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>設計守則</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>錯誤集錦</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="純函數"><a href="#純函數" aria-hidden="true" class="header-anchor">#</a> 純函數</h1> <p>純函數是滿足以下條件才能稱為純函數</p> <ul><li>當輸入參數相同時, 它是一個始終回傳相同的結果</li></ul> <p>例如呼叫以下 add 方法兩次, ans 結果始終一定是一樣</p> <div class="language- extra-class"><pre class="language-text"><code>let ans = add(1, 2)
</code></pre></div><ul><li>不會產生副作用(Side Effect)</li></ul> <p>當在指定原本輸入的變數或物件時, 經過這個方法處理完畢之後, 如果會變動原本的變數或物件的值，就稱為是&quot;具有副作用(Side Effect)).</p> <p>例如下面 login 方法, 輸入參數 player 的內容被改變, 這叫做有 &quot;副作用&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>function login(player: PlayerInfo): boolean {
    player.status = &quot;signed&quot;;
    return true;
}
</code></pre></div><ul><li>不依賴任何外部的變數</li></ul> <p>像下面 sayHello 方法需要外面的 count 變數當計數器, 這就是依賴外部的變數</p> <div class="language- extra-class"><pre class="language-text"><code>let count: number = 1;
function sayHello(name: string): string {
    count++;
    return `${name}, login ${count} times.`;
}
</code></pre></div><p>一個典型的純函數的例子如下</p> <div class="language- extra-class"><pre class="language-text"><code>function add(a: number, b: number): number {
    return a + b;
}
</code></pre></div><h3 id="記憶化-memoization"><a href="#記憶化-memoization" aria-hidden="true" class="header-anchor">#</a> 記憶化(memoization)</h3> <p>記憶化(memoization) 在程式開發技術中, 是一種提高程式碼執行速度的優化技術, 假設某個方法需要大量計算時間或大量資料才能得到結果並回傳回去, 當這個方法又再一次被呼叫, 而不用再一次計算來節省計算時間.</p> <p>一個典型的大量計算例子就是遞迴計算階乘factorial 函數</p> <div class="language- extra-class"><pre class="language-text"><code>function factorial(n: number): number {
   if( n &lt;= 0 ) {
      return 1;
   }
   return n * factorial(n - 1);
}
</code></pre></div><p>如果階乘factorial 函數用了記憶化(memoization) 技術, 就可以提高階乘的性能, 也就是俗稱的快取(Cache) 技術.</p> <h3 id="閉包-closure"><a href="#閉包-closure" aria-hidden="true" class="header-anchor">#</a> 閉包(Closure)</h3> <p>閉包(Closure) 就是帶有狀態的函數, 以下示範了甚麼是閉包函數</p> <div class="language- extra-class"><pre class="language-text"><code>function addCounter() {
    let counter = 0;
    return function() {
        counter = counter + 1
        return counter;
    }
}
</code></pre></div><p>當你呼叫上面的 addCounter 函數放到 obj 變數, 然後你呼叫 obj() 函數它會輸出 1, 再次呼叫 obj() 函數, 它會輸出 2, 以此類推...</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = addCounter();
obj();
obj();
</code></pre></div><p>之所以提到這個閉包函數, 我們可以用來製作具有 &quot;快取&quot; 的函數.</p> <p>下面的 memoize 函數, 提供一個輸入參數, 參數類型是 &quot;方法&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>function memoize(fn: Function) {
    const cache: any = {};
    return function(...args: any[]) {
        const argsKey = JSON.stringify(args);
        if( !cache.hasOwnProperty(argsKey) ) {
            let result = fn(...args);
            cache[argsKey] = result;
            return result;
        }
        return cache[argsKey];
    }
}
</code></pre></div><p>上面程式碼表明 memoize 函數帶有&quot;狀態&quot;, 就是 cache 變數.</p> <p>然後 memoize 函數回傳一個新的函數. 在新的函數中, 會把輸入參數的內容先轉換為 cache key 值, 如下</p> <div class="language- extra-class"><pre class="language-text"><code>const argsKey = JSON.stringify(args);
</code></pre></div><p>然後新函數檢查快取內容是否有這個 key 存在? 如果 cache 不存在, 就呼叫 fn 函數取得結果, 並將結果存入快取, 再回傳結果.</p> <div class="language- extra-class"><pre class="language-text"><code>if( !cache.hasOwnProperty(argsKey) ) {
    let result = fn(...args);
    cache[argsKey] = result;
    return result;
}
</code></pre></div><p>如果快取內容已經存在, 就回傳快取結果.</p> <div class="language- extra-class"><pre class="language-text"><code>return cache[argsKey];
</code></pre></div><p>要使用這個 memoize 函數, 可以這樣使用, 例如快取 add 方法</p> <div class="language- extra-class"><pre class="language-text"><code>let cachedAdd = memoize((a: number, b: number) =&gt; {
    return a + b;
});
</code></pre></div><p>然後在程式中使用 cachedAdd 函數, 就有具有 add 的快取功能了</p> <div class="language- extra-class"><pre class="language-text"><code>let c = cachedAdd(1, 2);
console.log(c);
</code></pre></div><p>為了證明這個快取機制是有效的, 你可以修改程式碼, 增加計數器, 計算 a + b 被呼叫幾次</p> <div class="language- extra-class"><pre class="language-text"><code>let counter = 0;
let cachedAdd = memoize((a: number, b: number) =&gt; {
    counter++;
    return a + b;
});
</code></pre></div><p>呼叫看看以下程式碼 cachedAdd(1,2) 兩次, 看看計數器的值是多少?</p> <div class="language- extra-class"><pre class="language-text"><code>let c = 0;
c = cachedAdd(1, 2);
c = cachedAdd(1, 2);
console.log(c);
console.log(counter);
</code></pre></div><p>具有快取功能的 cachedAdd 函數, 相同的輸入參數呼叫 cachedAdd 函數 N 次, 預期計數器的值應該是 1.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/Typescripts/chapter03-generic-curring.html" class="prev">泛型柯里化</a></span> <span class="next"><a href="/blog/Typescripts/chapter05-cache-decorator.html">快取裝飾器 Cache Decorator</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9ca61cd2.js" defer></script><script src="/blog/assets/js/2.ed8abbfc.js" defer></script><script src="/blog/assets/js/28.dc3b4330.js" defer></script>
  </body>
</html>

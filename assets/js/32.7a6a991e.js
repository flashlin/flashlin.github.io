(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{394:function(e,a,s){"use strict";s.r(a);var t=s(4),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"快取裝飾器-cache-decorator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快取裝飾器-cache-decorator","aria-hidden":"true"}},[e._v("#")]),e._v(" 快取裝飾器 Cache Decorator")]),e._v(" "),s("p",[e._v("之前的 memoize 快取函數是簡單閉包(Closure)的應用方式, 你可以試試動手做, 幫 memoize 函數加上快取過期時間, 或者觸發回應快取內容變更事件, 甚至增加建立快取使用不同的儲存媒體方式儲存.")]),e._v(" "),s("h3",{attrs:{id:"裝飾器-decorators"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#裝飾器-decorators","aria-hidden":"true"}},[e._v("#")]),e._v(" 裝飾器 Decorators")]),e._v(" "),s("p",[e._v("Typescript 的裝飾器Decorators 就像C# 的Attribute , 它可以實現AOP 面向切面編程開發, 不修改原來的程式碼的前提下, 給原來的程式碼增加額外的功能.")]),e._v(" "),s("p",[e._v("想要用Typescript 裝飾器, 必須修改tsconfig.json 參數如下")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n   "compilerOptions": {\n      "target": "es5",\n      "emitDecoratorMetadata": true,\n      "experimentalDecorators": true\n   }\n}\n')])])]),s("p",[e._v("首先Typescript 建立裝飾器的方式必須是回傳函數, 以下是方法裝飾器的典型範例")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function CustomDecorator() {\n   return (target: object, methodName: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor => {\n      ...\n      return descriptor;\n   };\n}\n")])])]),s("p",[e._v("方法裝飾器函數提供三個參數")]),e._v(" "),s("ul",[s("li",[e._v("target 類別(Class) 的原型定義或是方法的構造函數")]),e._v(" "),s("li",[e._v("methodName 成員函數的名稱")]),e._v(" "),s("li",[e._v("descriptor 成員的屬性描述")])]),e._v(" "),s("p",[e._v("首先我們來建立快取(Cache) 裝飾器, 以下示範我們是如何實作的")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function CacheDecorator() {\n   return (target: object, methodName: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor => {\n      if (!descriptor.hasOwnProperty('set') && descriptor.value) {\n         descriptor.value = createCacheDecorator(target, descriptor.value);\n      } else {\n         throw new Error(`Can't set cache decorator on a non-method`);\n      }\n      return descriptor;\n   };\n}\n")])])]),s("p",[e._v("首先CacheDecorator 裡面檢查成員名稱是否為非 'set' 開頭, 並且是否有提供 method 資訊")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (!descriptor.hasOwnProperty('set') && descriptor.value) {\n   ...\n}\n")])])]),s("p",[e._v("如果是的話, 就建立新的方法取代原本物件的方法定義")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("descriptor.value = createCacheDecorator(target, descriptor.value);\n")])])]),s("p",[e._v("如同之前的 memoize 函數, 同樣地我們建立 CacheDecorator 閉包函數")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function createCacheDecorator(target: object, method: (...args) => any): () => any {\n   const cache: {} = {};\n   return function(...args: any[]): any {\n      const argsKey: string = JSON.stringify(args);\n      if( !cache.hasOwnProperty(argsKey) ){\n         const res = method.call(this, ...args);\n         cache[argsKey] = res;\n         return res;\n      }\n      return cache[argsKey];\n   };\n}\n")])])]),s("p",[e._v("然後我們用新的 CacheDecorator 閉包函數取代物件中原本的方法.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("descriptor.value = createCacheDecorator(target, descriptor.value);\n")])])]),s("p",[e._v("假設你企圖在物件裡, 用我們實作的 CacheDecorator 裝飾器類別, 掛載在屬性上")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class SomeClass {\n   @CacheDecorator()\n   id: number = 1;\n}\n")])])]),s("p",[e._v("Typescript 將會顯示以下錯誤訊息")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Unable to resolve signature of property decorator when called as an expression.\n")])])]),s("p",[e._v("現在我們可以在任何物件中的任何方法, 掛載這個 CacheDecorator 裝飾器")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class User {\n   @CacheDecorator()\n   add(a: number, b: number): number {\n      return a + b;\n   }\n}\n")])])]),s("p",[e._v("這是多麼酷炫的應用, 可以讓我們不改變已現有的程式碼內容, 再加上具有快取(Cache) 的功能.")]),e._v(" "),s("h3",{attrs:{id:"物件導向的-多重繼承-解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物件導向的-多重繼承-解","aria-hidden":"true"}},[e._v("#")]),e._v(' 物件導向的 "多重繼承" 解')]),e._v(" "),s("p",[e._v("Typescript 的物件類別只能單一繼承, 因此你不能這樣做")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Plyaer extends Human, Animal {\n    ...\n}\n")])])]),s("p",[e._v("Typescript 會告知你, 物件不能夠多重繼承")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Classes can only extend a single class.\n")])])]),s("p",[e._v("但我們可以利用另一種方式來建構它們, 這種方式稱為混合(Mixins).")]),e._v(" "),s("p",[e._v("首先必須建立建構元類型")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type Constructor<T = {}> = new (...args: any[]) => T;\n")])])]),s("p",[e._v("然後我們提供一個為某個物件類型增加 address 屬性的方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('function AddAddress<TBase extends Constructor>(base: TBase) {\n    return class extends base {\n        address: string = "";\n    }\n}\n')])])]),s("p",[e._v("AddAddress 方法會另外產生新的物件類型並繼承 base, 再回傳這個新的物件類型.")]),e._v(" "),s("p",[e._v("於是我們就可以這樣使用... 幫 User 類型增加 address 屬性")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('class User {\n    name: string = "flash";\n}\n\nconst AddressUser = AddAddresses(User);\n\nlet obj = new AddressUser();\nconsole.log(obj.address);\n')])])]),s("p",[e._v("同樣地我們也能為物件類別增加方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('function AddSayHello<TBase extends Constructor>(base: TBase) {\n    return class extends base {\n        sayHello(msg: string): void {\n            console.log("hello " + msg);\n        }\n    }\n}\n\nconst UserCanSayHello = AddSayHello(User);\n\nlet obj = new UserCanSayHello();\nconsole.log(obj.sayHello());\n')])])])])}),[],!1,null,null,null);a.default=r.exports}}]);
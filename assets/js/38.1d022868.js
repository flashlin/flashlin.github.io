(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{403:function(a,e,t){"use strict";t.r(e);var n=t(0),s=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"純函數"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#純函數","aria-hidden":"true"}},[a._v("#")]),a._v(" 純函數")]),a._v(" "),t("p",[a._v("純函數是滿足以下條件才能稱為純函數")]),a._v(" "),t("ul",[t("li",[a._v("當輸入參數相同時, 它是一個始終回傳相同的結果")])]),a._v(" "),t("p",[a._v("例如呼叫以下 add 方法兩次, ans 結果始終一定是一樣")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let ans = add(1, 2)\n")])])]),t("ul",[t("li",[a._v("不會產生副作用(Side Effect)")])]),a._v(" "),t("p",[a._v('當在指定原本輸入的變數或物件時, 經過這個方法處理完畢之後, 如果會變動原本的變數或物件的值，就稱為是"具有副作用(Side Effect)).')]),a._v(" "),t("p",[a._v('例如下面 login 方法, 輸入參數 player 的內容被改變, 這叫做有 "副作用"')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('function login(player: PlayerInfo): boolean {\n    player.status = "signed";\n    return true;\n}\n')])])]),t("ul",[t("li",[a._v("不依賴任何外部的變數")])]),a._v(" "),t("p",[a._v("像下面 sayHello 方法需要外面的 count 變數當計數器, 這就是依賴外部的變數")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let count: number = 1;\nfunction sayHello(name: string): string {\n    count++;\n    return `${name}, login ${count} times.`;\n}\n")])])]),t("p",[a._v("一個典型的純函數的例子如下")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function add(a: number, b: number): number {\n    return a + b;\n}\n")])])]),t("h3",{attrs:{id:"記憶化-memoization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#記憶化-memoization","aria-hidden":"true"}},[a._v("#")]),a._v(" 記憶化(memoization)")]),a._v(" "),t("p",[a._v("記憶化(memoization) 在程式開發技術中, 是一種提高程式碼執行速度的優化技術, 假設某個方法需要大量計算時間或大量資料才能得到結果並回傳回去, 當這個方法又再一次被呼叫, 而不用再一次計算來節省計算時間.")]),a._v(" "),t("p",[a._v("一個典型的大量計算例子就是遞迴計算階乘factorial 函數")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function factorial(n: number): number {\n   if( n <= 0 ) {\n      return 1;\n   }\n   return n * factorial(n - 1);\n}\n")])])]),t("p",[a._v("如果階乘factorial 函數用了記憶化(memoization) 技術, 就可以提高階乘的性能, 也就是俗稱的快取(Cache) 技術.")]),a._v(" "),t("h3",{attrs:{id:"閉包-closure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#閉包-closure","aria-hidden":"true"}},[a._v("#")]),a._v(" 閉包(Closure)")]),a._v(" "),t("p",[a._v("閉包(Closure) 就是帶有狀態的函數, 以下示範了甚麼是閉包函數")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function addCounter() {\n    let counter = 0;\n    return function() {\n        counter = counter + 1\n        return counter;\n    }\n}\n")])])]),t("p",[a._v("當你呼叫上面的 addCounter 函數放到 obj 變數, 然後你呼叫 obj() 函數它會輸出 1, 再次呼叫 obj() 函數, 它會輸出 2, 以此類推...")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let obj = addCounter();\nobj();\nobj();\n")])])]),t("p",[a._v('之所以提到這個閉包函數, 我們可以用來製作具有 "快取" 的函數.')]),a._v(" "),t("p",[a._v('下面的 memoize 函數, 提供一個輸入參數, 參數類型是 "方法"')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function memoize(fn: Function) {\n    const cache: any = {};\n    return function(...args: any[]) {\n        const argsKey = JSON.stringify(args);\n        if( !cache.hasOwnProperty(argsKey) ) {\n            let result = fn(...args);\n            cache[argsKey] = result;\n            return result;\n        }\n        return cache[argsKey];\n    }\n}\n")])])]),t("p",[a._v('上面程式碼表明 memoize 函數帶有"狀態", 就是 cache 變數.')]),a._v(" "),t("p",[a._v("然後 memoize 函數回傳一個新的函數. 在新的函數中, 會把輸入參數的內容先轉換為 cache key 值, 如下")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const argsKey = JSON.stringify(args);\n")])])]),t("p",[a._v("然後新函數檢查快取內容是否有這個 key 存在? 如果 cache 不存在, 就呼叫 fn 函數取得結果, 並將結果存入快取, 再回傳結果.")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("if( !cache.hasOwnProperty(argsKey) ) {\n    let result = fn(...args);\n    cache[argsKey] = result;\n    return result;\n}\n")])])]),t("p",[a._v("如果快取內容已經存在, 就回傳快取結果.")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("return cache[argsKey];\n")])])]),t("p",[a._v("要使用這個 memoize 函數, 可以這樣使用, 例如快取 add 方法")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let cachedAdd = memoize((a: number, b: number) => {\n    return a + b;\n});\n")])])]),t("p",[a._v("然後在程式中使用 cachedAdd 函數, 就有具有 add 的快取功能了")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let c = cachedAdd(1, 2);\nconsole.log(c);\n")])])]),t("p",[a._v("為了證明這個快取機制是有效的, 你可以修改程式碼, 增加計數器, 計算 a + b 被呼叫幾次")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let counter = 0;\nlet cachedAdd = memoize((a: number, b: number) => {\n    counter++;\n    return a + b;\n});\n")])])]),t("p",[a._v("呼叫看看以下程式碼 cachedAdd(1,2) 兩次, 看看計數器的值是多少?")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let c = 0;\nc = cachedAdd(1, 2);\nc = cachedAdd(1, 2);\nconsole.log(c);\nconsole.log(counter);\n")])])]),t("p",[a._v("具有快取功能的 cachedAdd 函數, 相同的輸入參數呼叫 cachedAdd 函數 N 次, 預期計數器的值應該是 1.")])])}),[],!1,null,null,null);e.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{398:function(e,t,a){"use strict";a.r(t);var r=a(4),d=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"資料庫參數探測問題-parameter-sniffing-problem"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#資料庫參數探測問題-parameter-sniffing-problem","aria-hidden":"true"}},[e._v("#")]),e._v(" 資料庫參數探測問題 (Parameter Sniffing Problem)")]),e._v(" "),a("p",[e._v("2019-11-02")]),e._v(" "),a("p",[e._v("前陣子小明跑來問說甚麼是參數探測?")]),e._v(" "),a("p",[e._v("還沒開始說明之前, 先介紹以下是資料庫在資料表找資料的幾種方法:")]),e._v(" "),a("ul",[a("li",[e._v("Table Scan")])]),e._v(" "),a("p",[e._v("當資料表沒有任何Index, 資料庫引擎讀取整個資料表逐筆比對, 這是最沒效率的做法.")]),e._v(" "),a("ul",[a("li",[e._v("Clustered Index Scan")])]),e._v(" "),a("p",[e._v("評估查詢條件無法藉由其他Index 加速, 資料庫引擎逐筆讀取整個Clustered Index 進行比對, 全部資料要掃一次.")]),e._v(" "),a("p",[e._v("另外由於Clustered Index 順序與資料實際儲存順序一致, 不需要額外尋找動作(例如:Key Lookup) 就能讀到SELECT 要求的欄位.")]),e._v(" "),a("ul",[a("li",[e._v("Index Scan")])]),e._v(" "),a("p",[e._v("查詢條件包含Index 的組成欄位, 資料庫引擎逐筆讀取Index(由第一筆到最後一筆), 從中找出符合資料.")]),e._v(" "),a("p",[e._v("若SELECT 要求Index 未包含的欄位, 則還需透過Key Lookup 找到資料列讀取資料.")]),e._v(" "),a("p",[a("strong",[e._v("不管最後找到幾筆都得讀完整個Index.")])]),e._v(" "),a("ul",[a("li",[e._v("Index Seek")])]),e._v(" "),a("p",[e._v("當查詢條件包含Index 組成的第一個欄位(由此可知, 建立多欄位Index 時順序很重要), 資料庫引擎可透過B-Tree 演算法找到第一筆相符資料，"),a("strong",[e._v("逐筆讀取直到資料不相符為止")])]),e._v(" "),a("p",[e._v("必要時還需配合Key Lookup.")]),e._v(" "),a("p",[e._v("Index Seek 時間長短與結果筆數多寡成正比.")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("以上四種查詢方法越後面效率越快, 一般而言 Index Seek 比Index Scan 有效率.")]),e._v(" "),a("p",[e._v("假設有一個資料表(SalesOrderDetail) 的資料分佈如下")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("ProductId")]),e._v(" "),a("th",[e._v("訂單資料筆數")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1000")])]),e._v(" "),a("tr",[a("td",[e._v("2")]),e._v(" "),a("td",[e._v("3")])])])]),e._v(" "),a("p",[e._v("當你執行以下指令並觀察執行計劃, 你可以發現資料庫引擎用Index Scan 方法讀取資料.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("SELECT ProductId, OrderData FROM SalesOrderDetail\nWHERE ProductId = 1\n")])])]),a("p",[e._v("但你改用查詢 ProductId = 2 去查詢資料並觀察執行計劃, 資料庫引擎用Index Seek 方式去查詢資料")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("SELECT ProductId, OrderData FROM SalesOrderDetail\nWHERE ProductId = 2\n")])])]),a("p",[e._v("由此可知")]),e._v(" "),a("ul",[a("li",[e._v("結果筆數多時, Index Scan 比Index Seek 划算.")]),e._v(" "),a("li",[e._v("結果筆數少時, Index Seek 效率高")])]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("一般來說Stored procedure 在第一次執行時, 資料庫引擎會把編譯(compile) 好的執行計畫丟到快取裡面. 避免每次執行Stored procedure 都必須耗費CPU 重新編譯執行.")]),e._v(" "),a("p",[e._v("所以當你建立上述SalesOrderDetail 查詢StoreProcedure 的時候.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CREATE PROC GetOrderDetail\n   @productId int\nBEGIN\nAS\n   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail\n   WHERE ProductId = @productId\nEND\n")])])]),a("p",[e._v("一旦你執行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("EXEC dbo.GetOrderDetail 1\n")])])]),a("p",[e._v("資料庫引擎就會用Index Scan 方法讀取資料.\n然後建立這個GetOrderDetail SP執行計畫快取.")]),e._v(" "),a("p",[e._v("然後你再執行另一個查詢條件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("EXEC dbo.GetOrderDetail 2\n")])])]),a("p",[e._v("資料庫引擎就會用先前的執行快取計畫, 再一次用Index Scan 方法讀取資料. 查詢結果就會比較慢.")]),e._v(" "),a("p",[e._v("由此可知, 如果第一次執行Stored procedure 所選擇的是資料分布非常極端的情況, 可能造成之後再執行此Stored procedure時, 會產生查詢效能問題.")]),e._v(" "),a("p",[e._v('這種情形, 我們稱為 "參數探測" 問題.')]),e._v(" "),a("h2",{attrs:{id:"解決方案探討"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解決方案探討","aria-hidden":"true"}},[e._v("#")]),e._v(" 解決方案探討")]),e._v(" "),a("h3",{attrs:{id:"解決方案1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解決方案1","aria-hidden":"true"}},[e._v("#")]),e._v(" 解決方案1")]),e._v(" "),a("p",[e._v("如果我們的語法並不常常執行, 但每次執行時都查詢資料量的結果集差異非常大, 這邊建議的解決方案是每次執行的時候去Recompile(重新編譯) 你的Stored Procedure.")]),e._v(" "),a("p",[e._v("像是每月統計報表就很適合這種方案.")]),e._v(" "),a("p",[e._v("而Recompile 有幾個做法:")]),e._v(" "),a("ul",[a("li",[e._v("針對整個Procedure 層級做Recompile")])]),e._v(" "),a("p",[e._v("如下 WITH RECOMPILE 示範")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CREATE PROC GetOrderDetail\n   @productId int\nBIGIN WITH RECOMPILE\nAS\n   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail\n   WHERE ProductId = @productId\nEND\n")])])]),a("ul",[a("li",[e._v("針對Stored Procedure 中個別語法進行Recompile")])]),e._v(" "),a("p",[e._v("如下 OPTION(RECOMPILE) 示範")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CREATE PROC GetOrderDetail\n   @productId int\nBIGIN\nAS\n   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail\n   WHERE ProductId = @productId OPTION(RECOMPILE)\nEND\n")])])]),a("h3",{attrs:{id:"解決方案2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解決方案2","aria-hidden":"true"}},[e._v("#")]),e._v(" 解決方案2")]),e._v(" "),a("p",[e._v("假設你的語法頻繁查詢, RECOMPILE 顯然不是一個非常好的方法.\n如果你不追求每次的查詢都是完美的, 我們可以透過OPTIMIZE FOR UNKNOWN 或者Local Variable 來解決.")]),e._v(" "),a("ul",[a("li",[e._v("OPTIMIZE FOR UNKNOWN")])]),e._v(" "),a("p",[e._v("它是讓資料庫引擎在編譯時, 告訴其參數是未知的, 只要Query Optimizer 認定參數的值是未知的, 它會選擇一個中庸的值, 如果是等於 (=) 的運算子, 他的預估行數會是")]),e._v(" "),a("blockquote",[a("p",[e._v("Total Rows / (Distinct 此 Column組合數)")])]),e._v(" "),a("p",[e._v("如果是 \"非等於\" 的運算子(例如 '>' ), 預估行數則會是")]),e._v(" "),a("blockquote",[a("p",[e._v("全部的Row的30%")])]),e._v(" "),a("p",[e._v("以下是 OPTIMIZE FOR UNKNOWN 範例")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CREATE PROC GetOrderDetail\n   @productId int\nBIGIN\nAS\n   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail\n   WHERE ProductId = @productId OPTION(OPTIMIZE FOR UNKNOWN)\nEND\n")])])]),a("p",[e._v("如果是SQL 2008 以前的版本, 也有其他解決方案, 就是Local Variable, 透過Local variable 承接傳進來的參數, 亦可達到與OPTIMIZE FOR UNKNOWN一樣的效果, 只可惜寫起來可讀性很差.")]),e._v(" "),a("h2",{attrs:{id:"解決方案3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解決方案3","aria-hidden":"true"}},[e._v("#")]),e._v(" 解決方案3")]),e._v(" "),a("p",[e._v("將一種查詢拆分成多種查詢, 適合頻繁查詢, 且追求每次查詢都能有近乎完美效能的解法.")]),e._v(" "),a("p",[e._v("例如你很清楚查詢時候在某些條件下要用哪一種查詢方法.")]),e._v(" "),a("p",[e._v("以下是當結果資料很大的時候要用Index Scan 方法讀取資料.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail WITH(FORCESCAN)\n   WHERE ProductId = @productId\n")])])]),a("p",[e._v("以下是當結果資料很少的時候要用Index Seek 方法讀取資料.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   SELECT ProductId, OrderData FROM dbo.SalesOrderDetail WITH(FORCESEEK)\n   WHERE ProductId = @productId\n")])])]),a("p",[e._v("建立一支Stored Procedure 根據傳進來的查詢條件選擇適當的查詢條件執行.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CREATE PROC GetOrderDetail\n   @productId int\nBIGIN\nAS\n   IF(@productId = 1)\n      SELECT ProductId, OrderData FROM dbo.SalesOrderDetail WITH(FORCESCAN)\n      WHERE ProductId = @productId\n   ELSE\n      SELECT ProductId, OrderData FROM dbo.SalesOrderDetail WITH(FORCESEEK)\n      WHERE ProductId = @productId\nEND\n")])])]),a("h2",{attrs:{id:"結尾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#結尾","aria-hidden":"true"}},[e._v("#")]),e._v(" 結尾")]),e._v(" "),a("p",[e._v("我是 "),a("strong",[e._v("菜鳥的水準")]),e._v(" 又是在意 "),a("strong",[e._v("簡潔的程式碼")]),e._v(" , 如果遇到資料差異太大問題, 所以就選")]),e._v(" "),a("blockquote",[a("p",[e._v("OPTIMIZE FOR UNKNOWN")])]),e._v(" "),a("p",[e._v("來解決這惱人的問題.")])])}),[],!1,null,null,null);t.default=d.exports}}]);
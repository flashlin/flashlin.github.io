(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{380:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"typescript-與-javascript-proxy-和-reflect-搭配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typescript-與-javascript-proxy-和-reflect-搭配","aria-hidden":"true"}},[t._v("#")]),t._v(" Typescript 與 Javascript Proxy 和 Reflect 搭配")]),t._v(" "),r("p",[t._v("2019-10-15")]),t._v(" "),r("h2",{attrs:{id:"javascript-的-proxy-物件-reflect-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的-proxy-物件-reflect-api","aria-hidden":"true"}},[t._v("#")]),t._v(" Javascript 的 Proxy 物件 & Reflect API")]),t._v(" "),r("p",[t._v("下面表格是 Proxy 物件在各種瀏覽器版本中的支援程度, 資料參考來源從  "),r("a",{attrs:{href:"https://caniuse.com/#feat=proxy",target:"_blank",rel:"noopener noreferrer"}},[t._v("caniuse"),r("OutboundLink")],1),t._v(" 網站取得")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Browser")]),t._v(" "),r("th",[t._v("Support Version")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("IE")]),t._v(" "),r("td",[r("s",[t._v("6")]),t._v(" - "),r("s",[t._v("10")]),t._v(", "),r("s",[t._v("11")])])]),t._v(" "),r("tr",[r("td",[t._v("Edge")]),t._v(" "),r("td",[t._v("12-18, 76")])]),t._v(" "),r("tr",[r("td",[t._v("Firefox")]),t._v(" "),r("td",[t._v("18-68, 69")])]),t._v(" "),r("tr",[r("td",[t._v("Chrome")]),t._v(" "),r("td",[t._v("49-76, 77")])]),t._v(" "),r("tr",[r("td",[t._v("Safari")]),t._v(" "),r("td",[t._v("10-12.1, 13")])]),t._v(" "),r("tr",[r("td",[t._v("Opera")]),t._v(" "),r("td",[t._v("36-60, 62")])]),t._v(" "),r("tr",[r("td",[t._v("iOS Safari")]),t._v(" "),r("td",[t._v("10-12.3, 13.1")])]),t._v(" "),r("tr",[r("td",[t._v("Opera Mini")]),t._v(" "),r("td",[t._v("All Not support")])]),t._v(" "),r("tr",[r("td",[t._v("Android Browser")]),t._v(" "),r("td",[t._v("76")])]),t._v(" "),r("tr",[r("td",[t._v("Opera Mobile")]),t._v(" "),r("td",[t._v("46")])]),t._v(" "),r("tr",[r("td",[t._v("Chrome for Android")]),t._v(" "),r("td",[t._v("76")])]),t._v(" "),r("tr",[r("td",[t._v("Firefox for Android")]),t._v(" "),r("td",[t._v("68")])]),t._v(" "),r("tr",[r("td",[t._v("UC Browser for Android")]),t._v(" "),r("td",[t._v("12.12")])]),t._v(" "),r("tr",[r("td",[t._v("Samsung Internet")]),t._v(" "),r("td",[t._v("5-9.2, 10.1")])]),t._v(" "),r("tr",[r("td",[t._v("QQ Browser")]),t._v(" "),r("td",[r("s",[t._v("1.2")])])]),t._v(" "),r("tr",[r("td",[t._v("Baidu Browser")]),t._v(" "),r("td",[r("s",[t._v("7.12")])])]),t._v(" "),r("tr",[r("td",[t._v("KaiOS Browser")]),t._v(" "),r("td",[t._v("2.5")])])])]),t._v(" "),r("blockquote",[r("p",[t._v("以上版本號碼有刪除的樣式, 表示不支援")])]),t._v(" "),r("p",[t._v("Proxy 和Reflect 是ES6 新增的API, Proxy 是一個函式物件, 它提供一個機會讓你能介入一般物件的基本操作行為, 很像 interceptor 會做的事情一樣.")]),t._v(" "),r("p",[t._v("使用的方法如下")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const proxyObj = new Proxy(target, handler);\n")])])]),r("ul",[r("li",[t._v("target 就是你想要代理的對象")]),t._v(" "),r("li",[t._v("handler 則是一個物件, 定義了所有你想替 target 代為管理的操作定義")])]),t._v(" "),r("p",[t._v("以下是一個典型的範例, 示範了 cat 物件被代理成 catProxy 物件, 然後不能存取私有變數的方法.")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let cat = {\n  _secret: 'I am Mr.Brain',\n  name: 'Flash'\n};\n\nlet catProxy = new Proxy(cat, {\n  get: function (target, prop) {\n     if( prop.startsWith('_') ) {\n        console.log('不能存取私有變數');\n        return false;\n     }\n     return target[prop];\n  },\n  set: function (target, prop, value) {\n    if (prop.startsWith('_')) {\n      console.log('不能修改私有變數');\n      return false;\n    }\n    target[prop] = value;\n  },\n  has: function (target, prop) {\n    return prop.startsWith('_') ? false : (prop in target);\n  }\n});\n")])])]),r("h2",{attrs:{id:"不是什麼都可以被代理的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不是什麼都可以被代理的","aria-hidden":"true"}},[t._v("#")]),t._v(" 不是什麼都可以被代理的")]),t._v(" "),r("p",[t._v("如果你的物件擁有 configurable: false 與 writable: false 的屬性，那該物件就無法被 proxy 代理, 如下示範")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const target = Object.defineProperties({}, {\n  Cat: {\n    writable: false,\n    configurable: false\n  },\n});\n\nconst handler = {\n  get(target, propKey) {\n    return '???';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\nproxy.FooBar\n// Uncaught TypeError: 'get' on proxy: property 'FooBar' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'undefined' but got '???')\n")])])]),r("h2",{attrs:{id:"reflect-與-proxy-的搭配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reflect-與-proxy-的搭配","aria-hidden":"true"}},[t._v("#")]),t._v(" Reflect 與 Proxy 的搭配")]),t._v(" "),r("p",[t._v("我們在 Proxy 中, 如果需要 target 物件的預設操作, 使用 Reflect 會更清楚, 如下示範")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('const loggedObj = new Proxy(obj, {\n  get: function(target, name) {\n    console.log("get", target, name);\n    return Reflect.get(target, name);\n  }\n});\n')])])]),r("p",[t._v("以上是property 的proxy, 下面是method proxy 示範")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('let cat = {\n\tname: "Kitty",\n\tmethod1: function(msg){\n\t\tconsole.log("cat: " + this.name + " say " + msg);\n\t},\n};\n\nvar catProxy = new Proxy(cat, {\n\tget: function(target, propKey, receiver){\n\t\t//我只要攔截方法(method calls), 不要屬性(property access)\n\t\tvar propValue = target[propKey];\n\t\tif (typeof propValue != "function"){\n\t\t\treturn propValue;\n\t\t}\n\t\telse{\n\t\t\treturn function() {\n\t\t\t\tconsole.log("intercepting call to " + propKey + " in cat " + target.name);\n\t\t\t\t//"this" 指向 proxy, 就像"receiver"\n\t\t\t\treturn propValue.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t}\n});\n')])])]),r("p",[t._v('以上Proxy 的概念性, 在沒有ES6 語法之前, 使用Typescript 撰寫 "裝飾者模式" 就可以做到, 如下所示')]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('interface ICat { \n   sayHello(msg: string): void;\n}\n\nclass RealCat implements ICar {\n   public sayHello(msg: string): void {\n      console.log(\'RealCat: \' + msg);\n   }\n}\n\nclass CatProxy implements ICat {\n   private _realCat: RealCat;\n\n   constructor(realCat: RealCat) {\n      this._realCat = realCat;\n   }\n\n   public sayHello(msg: string): void {\n      console.log("Hey! I am Kitty");\n      this._realCat.sayHello(msg);\n   }\n}\n\nlet catProxy = new CatProxy(new RealCat());\ncatProxy.sayHello("Hello Proxy World");\n')])])]),r("h2",{attrs:{id:"typescript-與-proxy-reflect-搭配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typescript-與-proxy-reflect-搭配","aria-hidden":"true"}},[t._v("#")]),t._v(" Typescript 與 Proxy & Reflect 搭配")]),t._v(" "),r("p",[t._v("使用上述的裝飾者模式時候, 假如 ICat 介面中的方法和屬性加起來有100 個, 你就得在 CatProxy 一一實作包裝並呼叫 _realCat.")]),t._v(" "),r("p",[t._v("但你又是個懶人不想一一手動去實作, 你可以用 Proxy 和 Reflect 來幫忙實作每一個 ICat 的公開方法和屬性, 如下示範Typescript 程式碼是如何做到這件事情")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function fakeBaseClass<T>() : new() => Pick<T, keyof T> { \n   return class {} as any;\n}\n\nclass CatProxy extends fakeBaseClass<RealCat>() { \n   private _realCat: RealCat;\n   constructor(cat: RealCat) {\n      super();\n      this._realCat = cat;\n      let handler = {\n         get: function(target: CatProxy, prop: keyof RealCat, receiver: any) {\n            if(RealCat.prototype[prop] !== null) {\n               return target._realCat[prop];\n            }\n            return Reflect.get(target, prop, receiver);\n         }\n      };\n      return new Proxy(this, handler);\n   }\n}\n")])])]),r("p",[t._v("如此一來你可以開始只複寫(override) ICat 介面其中一部分的方法或屬性.")])])}),[],!1,null,null,null);e.default=n.exports}}]);